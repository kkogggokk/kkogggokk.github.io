---
layout: post
title:  "[Numpy]Unit01.넘파이 배열 프로그래밍"
date:   2021-02-22
categories: Numpy
tags: Python Numpy 
---

* content
{:toc}

[Numpy]넘파이 배열 프로그래밍







# 1. 넘파이 배열 

## 1.1 넘파이 패키지 임포트
- 배열을 사용하기 위해서 넘파이 패키지를 임포트.
- 넘파이는 np라는 이름으로 임포트 하는 것이 관례.


```python
import numpy as np
```

## 1.2 1차원 배열 만들기
- 넘파이의 array함수에 리스트를 넣으면 ndarray(배열)클래스 객체로 변환
- 리스트와 비슷해보이지만 type명령으로 자료형을 보면 ndarray(배열)이다. 
- 배열객체와 리스트 객체의 차이점 
    - 리스트 클래스 객체 : 각각의 원소가 다른 자료형 가능.
    - 배열 클래스 객체 : 모든 원소가 같은 자료형. 
        - C 언어의 배열처럼 연속적인 메모리에 배치하기 때문에 같은 자료형
        - 따라서 원소에 대한 접근과 반복문 실행이 빠름


```python
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(a) # [0 1 2 3 4 5 6 7 8 9]
print(type(a)) # <class 'numpy.ndarray'>
```

## 1.3 벡터화 연산
- 배열 객체는 배열의 각 원소에 대한 반복 연산을 하나의 명령어로 처리하는 벡터화 연산을 지원 
- 벡터화 연산을 하면 for반복문 없이 한번의 연산을 할 수 있다.
- 따라서 계산 속도도 반복문을 사용할 때 보다 훨씬 빠르다. 
- 벡터화 연산은 비교연산과 논리 연산을 포함한 모든 종류의 수학 연산에 적용 


```python
# 리스트에서 각 원소에 2배 하기위해서는 for문을 돌려서 연산 해야한다. 

data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
answer = []
for di in data : 
    answer.append(2 * di)
print(answer) # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 
print(data * 2)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```


```python
# 하지만 벡터화 연산은 for 반복문 없이 한번에 연산 가능

x = np.array(data)
2 * x # array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])
```


```python
# 벡터화 연산은 비교연산, 논리연산 등 연산 가능 

a = np.array([1, 2, 3])
b = np.array([10, 20, 30])

print(2*a+b) # [12 24 36]
print(a == 2) # [False  True False]
print(b > 10) # [False  True  True]
print((a == 2)&(b > 10)) # [False  True False]
```

## 1.4 2차원 배열 만들기
- ndarray (N-dimension Array)는 1차원, 2차원, 3차원 배열 등 다차원 배열 자료구조를 지원.
- 리스트의 리스트(list of list)를 이용하여 2차원 배열 생성.
- 2차원 배열은 행렬(matrix)라고 하며 
    - 가로줄을 행(Row) , 바깥쪽 리스트의 길이 = 행렬의 행의 수 = 세로크기
    - 세로줄을 열(Column), 안쪽 리스트의 길이 = 행렬의 열의 수 = 가로크기
- ![그림넣기]()    


```python
a = np.array([[0, 1, 2],[3, 4, 5]]) # 2 * 3 array
print(len(a)) # 행의 갯수 : 2
print(len(a[0])) # 열의 갯수 : 3 
```

> <b>연습문제 1</b>
> - 넘파이를 사용하여 다음과 같은 행렬을 만든다.      
> 10 20 30 40         
> 50 60 70 80            


```python
a = np.array([[10, 20, 30, 40],[50, 60, 70, 80]])
a # array([[10, 20, 30, 40],[50, 60, 70, 80]])
```


```python
a = np.arange(10,90,10).reshape(2,4)
a # # array([[10, 20, 30, 40],[50, 60, 70, 80]])
```

## 1.5 3차원 배열만들기
- 리스트의 리스트의 리스트를 이용하면 3차원 배열 생성
- 3차원 배열의 깊이, 행, 열 <-- 구조 의 기준 axis0, axis1, axis2 다르다? 
- |--|--|
|--|--|
|3차원 배열의 깊이|len(d)|
|3차원 배열의 행|len(d[0]|
|3차원 배열의 열|len(d[0][0])|


```python
d = np.array([[[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]],
              [[11, 12, 13, 14],
               [15, 16, 17, 18],
               [19, 20, 21, 22]]])   # 2 x 3 x 4 array
len(d) # 3차원 배열의 깊이 : 2
len(d[0]) # 3차원 배열의 행 : 3 
len(d[0][0]) # 3차원 배열의 열 : 4 
```

## 1.6  배열의 차원과 크기
- 배열의 차원 : ndim속성
- 배열의 크기 : shape속성


```python
# 1차원 배열 
a = np.array([1, 2, 3]) 
print(a.ndim) # 1
print(a.shape) # (3,)

# 2차원 배열 
b = np.array([[0, 1, 2], [3, 4, 5]]) 
print(b.ndim) # 2
print(b.shape) # (2,3)

# 3차원 배열 
c = np.array([[[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]],
              [[11, 12, 13, 14],
               [15, 16, 17, 18],
               [19, 20, 21, 22]]])
print(c.ndim) # 3
print(c.shape) # (2, 3, 4)
```

## 1.7 배열의 인덱싱
### 1.7.1 1차원 배열인덱싱
- 1차원 배열의 인덱싱은 리스트의 인덱싱과 같다


```python
a = np.array([0, 1, 2, 3, 4])
a[2] # 2
a[-1] # 4
```

### 1.7.2 다차원배열 인덱싱
- 다차원 배열일때는 콤마를 사용해 접근
- 콤마로 구분된 차원을 축(axis)이라 한다.
- 축(axis) : 그래프의 x축 ,y축을 떠올리면 된다.


```python
a = np.array([[0, 1, 2], [3, 4, 5]])
a[0,0] # 0
a[0,1] # 1
a[-1,-1] # 마지막행의 마지막열 : 5
```

## 1.8 배열의 슬라이싱
- 배열 객체로 구현한 다차원 배열 원소 중 복수개를 접근하려면 일반적인 파이썬 슬라이싱과 콤마(,)를 함께 사용


```python
# 2차원 배열 슬라이싱
a = np.array([[0, 1, 2, 3], [4, 5, 6, 7]])
a[0,:] # 첫번째 행 전체 : array([0, 1, 2, 3])
a[:,1] # 두번째 열 전체 : array([1, 5])
a[1,1:] # 두번째 행 두번째 열부터 : array([5, 6, 7]) 
a[:2, :2] # array([[0, 1],[4, 5]]) 
```

> <B>연습문제 2</B>
> - m = np.array([[ 0,  1,  2,  3,  4], [ 5,  6,  7,  8,  9],[10, 11, 12, 13, 14]])
> - 1. 이 행렬에서 값 7을 인덱싱한다.
> - 2. 이 행렬에서 값 14을 인덱싱한다.
> - 3. 이 행렬에서 배열 [6,7] 을 슬라이싱한다.
> - 4. 이 행렬에서 배열 [7, 12] 을 슬라이싱 한다.
> - 5. 이 행렬에서 배열[[3, 4], [8, 9]]을 슬라이싱 한다. 


```python
m = np.array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9],[10, 11, 12, 13, 14]])
m[1,2] # 7 
m[-1,-1] # 14
m[1,1:3] # array([6, 7])
m[1:3,2] # array([ 7, 12])
m[:2, 3:5] # array([[3, 4],[8, 9]])
```

## 1.9 배열 인덱싱
- 넘파이 배열 객체의 또다른 강력한 기능 팬시인덱싱(
- DB질의(Query)기능을 수행
- 배열 인덱싱에는 대괄호([])안에 인덱싱 정보를 숫자나 슬라이스가 아닌 위치정보를 나타내는 또 다른 ndarray배열을 받을 수있다.
- 배열 인덱싱 방법 2가지
    - 1) 불리언(boolean)방식
    - 2) 정수 배열 방식

### 1.9.1 불리언 방식
- 인덱스 배열의 원소가 True, False 두 값으로만 구성
- 인덱스 배열의 크기가 원래 ndarray객체의 크기가 같아야 한다.

```python
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
idx = np.array([ True, False,  True, False,  True, False,  True, False,  True, False])
a[idx] # array([0, 2, 4, 6, 8])
```


```python
print(a % 2) # array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=int32)
print(a % 2 == 0) # array([ True, False,  True, False,  True, False,  True, False,  True, False])
print(a[a % 2 == 0]) # [0 2 4 6 8]
```

### 1.9.2 정수 배열 방식
- 인덱스 배열의 원소 각각이 원래 ndarray 객체 원소 하나를 가리키는 인덱스 정수여야 한다.
- 배열 인덱스의 크기가 원래 배열 크기와 달라도 상관없음. 
- 즉, 같은 원소를 반복해서 가리키는 경우 배열 인덱스가 원래 배열보다 더 커짐.


```python
# 1차원 배열에서 홀수번째 원소만 골라내기 
a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
idx = np.array([0, 2, 4, 6, 8])
a[idx] # array([11, 33, 55, 77, 99])
```


```python
# 배열 인덱스의 크기가 원래 배열 크기와 같지 않아도 됨.
a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
idx = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2])
a[idx] # array([11, 11, 11, 11, 11, 11, 22, 22, 22, 22, 22, 33, 33, 33, 33, 33])
```

### 1.9.3 다차원 배열 인덱싱


```python
a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
a[:, [True, False, False, True]] # array([[ 1,  4], [ 5,  8], [ 9, 12]])
a[[2, 0, 1],:] # array([[ 9, 10, 11, 12], [ 1,  2,  3,  4],[ 5,  6,  7,  8]])
```

> <B>연습문제 3 </B>
> - x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 29, 20])
> - 1. 이 배열에서 3의 배수를 찾아라.
> - 2. 이 배열에서 4로 나누면 1이 남는 수를 찾아라.
>- 3. 이 배열에서 3으로 나누면 나누어지고 4로 나누면 1이 남은 수를 찾아라.


```python
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 29, 20])
x[x % 3 == 0] # array([ 3,  6,  9, 12, 15, 18])
x[x % 4 == 1] # array([ 1,  5,  9, 13, 17, 29])
x[(x % 3 == 0) | (x % 4 == 1)] # array([ 1,  3,  5,  6,  9, 12, 13, 15, 17, 18, 29])
```
--
# References      
> - 김성환, 엔코아 플레이데이터 (2021, 인공지능 개발자 3기 과정)
> - 데이터 사이언스 스쿨 [URL](https://datascienceschool.net/01%20python/03.00%203%EC%9E%A5%20%EB%84%98%ED%8C%8C%EC%9D%B4%20%EB%B0%B0%EC%97%B4%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html)(https://datascienceschool.net/intro.html)