---
layout: post
title:  "[Numpy]예제문제"
date:   2021-02-23
categories: Numpy
tags: Python Numpy 
---

* content
{:toc}

[Numpy]예제문제







```python
import numpy as np
```

# [1번]
> 10, 7, 5, 90, 100 을 가지는 1차원 배열을 생성.


```python
a1 = np.array([10, 7, 5, 90, 100])
a1 # array([ 10,   7,   5,  90, 100])
```

#  [2번]
> 100 ~ 200 범위의 숫자중 짝수를 가지는 배열을 생성.


```python
a2 = np.arange(100,201,2)
a2.shape #(51,)
a2

array([100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
       126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
       152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176,
       178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200])
```

#  [3번] 
> 2번에서 생성한 배열과 동일한 shape에 0을 원소로 가지는 배열 생성.


```python
#방법1 
a3 = np.zeros_like(a2) 

# 방법2 
a3 = np.zeros(shape = a2.shape) 

# 방법3 
a3 = np.linspace(100,200,num = 51) 

a3.shape # (51,)
```

#  [4번] 
> 1001 ~ 10000 범위의 정수 중 100의 배수만 가지는 3차원 배열을 생성. (shape은 상관없음.)


```python
a4 = np.arange(1001,10001,100).reshape(10,3,3)
len(a4) # 90
a4
```

#  [5번]
> (4,4) 형태의 단위행렬(항등행렬)을 생성.


```python
a5 = np.identity(4)
a5

array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])
```

#  [6번] 
> 다음 값을 가지는 배열을 생성하고 배열의 차원수(rank)와 형태, 총 원소(element)의 개수를 조회.      
> [[20, 90, 80, 100, -20, 30], [50, -10, 25, 120, -40, 90]]


```python
a6 = np.array([[20, 90, 80, 100, -20, 30], [50, -10, 25, 120, -40, 90]])
print(a6.ndim) # 차원수 : 2
print(a6.shape) # 형태 : (2,6)
print(a6.size) # 원소의 개수 : 12
print(a6.dtype) # 타입 : int32 
```

#  [7번]
> 정규분포를 따르는 난수를 가지는 (3,2,7) 형태의 배열을 생성.


```python
a7 = np.random.normal(size = (3, 2, 7)) # 평균 
a7
```

#  [8번]
> 1 ~ 100 사이의 정수 난수를 가지는 (4, 5) 형태의 배열을 생성한 뒤 arr.npy 파일로 저장.


```python
a8 = np.random.randint(1,101,(4,5))
np.save('arr.npy',a8)
a8

array([[ 26, 100,  46,  86,  98],
       [100,  20,  18,  92,  82],
       [ 79,  53,  22,  34,   5],
       [ 75,  95,  48,  92,  79]])
```


```python
# backup 폴더가 없으면 생성해서 backup폴더에 저장
import os 
if not os.path.isdir('backup') : 
    os.mkdir('backup')
np.save('arr.npy',a8)
```

#  [9번]
> 8번에서 저장한 arr.npy 의 배열을 불러와서 출력.


```python
a9 = np.load('arr.npy')
a9

array([[ 26, 100,  46,  86,  98],
       [100,  20,  18,  92,  82],
       [ 79,  53,  22,  34,   5],
       [ 75,  95,  48,  92,  79]])
```

#  [10번]
> 9번에서 불러온 배열에서 전체 값의 총합, 0번축 기준의 총합, 1번축 기준의 총합을 구하기.


```python
np.sum(a9)
np.sum(a9, axis = 0)
np.sum(a9, axis = 1)

array([356, 312, 193, 389])
```

#  [11번]
> 임의의 Boolean 값을 가지는 (5, 10) 배열을 생성하고 True의 개수를 출력하시오.


```python
#방법 1 
a11_1 = np.random.choice([True, False], size = (5,10))
print(a11_1)
print(np.sum(a11_1))

#방법 2 
a11_2 = np.random.randint(0,2, size = (5, 10), dtype = bool)
print(a11_2)
print(np.sum(a11_2))
```

#  [12-17번]
> - 아래 배열을 생성하고 12번 ~ 17번 문제는 아래 조건으로 생성한 배열을 가지고 푸세요.     
> 0 ~ 29 범위의 정수를 원소로 가지는 (5,6) 의 배열을 생성하고 변수에 저장.        


```python
arr = np.arange(0,30).reshape(5,6)
arr

array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29]])
```

12. index (1,1), (2,3), (1,5)의 값들 조회           


```python
arr[[1, 2, 1],[1, 3, 5]]

array([ 7, 15, 11])
```

13. index (1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3)의 값들을 조회. 


```python
arr[1:4, 1:4]

array([[ 7,  8,  9],
       [13, 14, 15],
       [19, 20, 21]])
```

14. 13와 같은 index의 값들을 뒤집어서(reversing) 조회.       


```python
arr[3:0:-1, 3:0:-1]

array([[21, 20, 19],
       [15, 14, 13],
       [ 9,  8,  7]])
```

15. 배열에서 15 이상의 원소만 조회해서 그 평균을 출력.     


```python
np.mean(arr[arr >= 15]) # 22.0 
```

16. 배열에서 15이상의 원소들의 index를 조회. (0축 index, 1축 index) 형식으로 출력.       
    ex: (0,0), (0,1) 식으로 출력


```python
indics = np.where(arr >= 15)
for idx in zip(indics[0], indics[1]) : #zip(배열, 배열): 한번 반복시마다 두 배열의 같은 index의 값을 tuple로 묶어서 반환
    print(idx, end = ' ')
    
(2, 3) (2, 4) (2, 5) (3, 0) (3, 1) (3, 2) (3, 3) (3, 4) (3, 5) (4, 0) (4, 1) (4, 2) (4, 3) (4, 4) (4, 5) 
```

17. 배열을 axis 1을 기준으로 내림차순으로 정렬. 
<!-- [[ 5,  4,  3,  2,  1,  0],
 [11, 10,  9,  8,  7,  6],
 [17, 16, 15, 14, 13, 12],
 [23, 22, 21, 20, 19, 18],
 [29, 28, 27, 26, 25, 24]]    -->


```python
np.sort(arr,axis = 1)[::-1,] 
```

# [18-21번] 
> - 아래 배열을 생성하고 18번 ~ 21번 문제는 아래 조건으로 생성한 배열을 가지고 푸세요.    
(3, 2) shape의 배열을 생성 하시오.          


```python
arr = np.arange(6).reshape(3,2)
arr.shape
```

18. 배열의 shape을 (1, 3, 2) 로 변환한 배열을 생성.      


```python
# 방법 1 
r1 = arr[np.newaxis,:]
r1.shape

# 방법 2 
r2 = arr[np.newaxis, ...]
r2.shape

# 방법 3 
r3 = arr.reshape(1, 3, 2)
r3.shape

# 방법 4 
r4 = np.expand_dims(arr, axis = 0)
r4.shape
```

19. 배열의 shape을 (1, 3, 2, 1) 로 변환한 배열을 생성.       


```python
# 방법 1
r1 = arr[np.newaxis,...,np.newaxis]
r1.shape

# 방법 2 
r2 = arr[np.newaxis,:,np.newaxis]
r2.shape

# 방법 3 
r3 = arr.reshape(1, 3, 2, 1)
r3.shape

# 방법 4 
r4 = np.expand_dims(arr, axis = [0,3])
r4.shape
```

20. 배열을 1차원 배열로 변환한 배열을 생성.    


```python
a20 = arr.flatten()
a20.shape # (6,)
```

21. 배열의 0번 축에 2개의 값을 추가. (추가된 배열의 shape: (5,2))     


```python
a21 = np.append(arr, [[60, 70], [80, 90]], axis = 0)
a21.shape
```

# [22-28번] 
> - 다음 배열은 5명 학생의 국어, 영어, 수학, 과학 시험 점수이다. 행(axis=0)은 각 학생의 시험점수이고 컬럼(axis=1)은 과목을 가리킨다.      
> [[ 60,  80,  60, 100], [ 80,  80,  90,  90],[ 90,  60,  70,  50],[ 40,  80,  60,  50],[ 60,  50,  70, 100]]   


```python
score = np.array([
 [ 60,  80,  60, 100],
 [ 80,  80,  90,  90],
 [ 90,  60,  70,  50],
 [ 40,  80,  60,  50],
 [ 60,  50,  70, 100]
])
```

22. 각 과목별 평균점수를 조회.


```python
mean_score = np.mean(score, axis = 0)
mean_score # array([66., 70., 70., 78.])
```

23. 각 과목별 평균 점수를 성적 배열에 추가. 


```python
np.append(score, [mean_score], axis = 0)

np.append(score, [np.mean(score, axis = 0)], axis = 0)

array([[ 60.,  80.,  60., 100.],
       [ 80.,  80.,  90.,  90.],
       [ 90.,  60.,  70.,  50.],
       [ 40.,  80.,  60.,  50.],
       [ 60.,  50.,  70., 100.],
       [ 66.,  70.,  70.,  78.]])
```

24. 각 학생들의 평균 점수 조회


```python
np.mean(score, axis = 1)
np.mean(score, axis = 1, keepdims = True)

array([[75. ],
       [85. ],
       [67.5],
       [57.5],
       [70. ]])
```

25. 과목별로 몇번째 학생의 성적이 가장 높은지 조회


```python
np.argmax(score, axis = 0) + 1 # 인덱스 0부터 시작하니 +1 해줘야 n번째 학생
array([3, 1, 2, 1], dtype=int64) # 국어 : 3번째학생, 영어 : 1번째 학생, 수학 :2번째 학생 , 과학 :1번째 학생  
```

26. 학생별로 어떤 과목의 점수가 가장 낮은지 조회.


```python
np.argmin(score, axis = 1) # array([0, 0, 3, 0, 1], dtype=int64)
subject[np.argmin(score, axis = 1)] # array(['국어', '국어', '과학', '국어', '영어'], dtype='<U2')
```

27. 각 과목별로 편차가 가장 적은 과목과 가장 큰 과목을 조회


```python
std_score = np.std(score, axis=0) # 과목별 편차 : [17.43559577 12.64911064 10.95445115 23.15167381]

argmax_std = np.argmax(std_score) # 편차가 가장 큰 과목 : 3
argmin_std = np.argmin(std_score) # 편차가 가장 작은 과목 : 2

subject[[argmax_std, argmin_std]] # 과목명으로 출력 :['과학' '수학']
```

28. 학생들 중 과목간의 점수의 편차가 가장 적은 학생을 조회


```python
std_score_stu = np.std(score, axis = 1) # 학생별 편차 : array([16.58312395,  5.        , 14.79019946, 14.79019946, 18.70828693])

argmax_std_stu = np.argmax(std_score_stu) # 편차가 가장 큰 학생 : 4
argmin_std_stu = np.argmin(std_score_stu) # 편차가 가장 작은 학생 : 1
```

# [29-30번] 
> - 다음 두 배열을 가지고 29,30번 문제를 푸세요.      
> A: [[1,2,3],[4,5,6],[7,8,9]]         
> B: [[10,20,30],[40,50,60],[70,80,90]]         


```python
A = np.array([[1,2,3],[4,5,6],[7,8,9]])
B = np.array([[10,20,30],[40,50,60],[70,80,90]])
```

29. 두 배열을 수직방향으로 합치기.      


```python
# 방법 1 
C = np.concatenate([A, B], axis = 0)

# 방법 2 
C = np.vstack([A, B])

array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 20, 30],
       [40, 50, 60],
       [70, 80, 90]])
```

30. 29에서 합친 배열을 수평방향으로 index 2를 기준으로 나누기.        


```python
# 방법 1 
D = np.split(C, [2], axis = 1)

# 방법 2 
D = np.hsplit(C, [2])

[array([[ 1,  2],
        [ 4,  5],
        [ 7,  8],
        [10, 20],
        [40, 50],
        [70, 80]]),
 array([[ 3],
        [ 6],
        [ 9],
        [30],
        [60],
        [90]])]
```

# [31-32번] 
> - 다음은 7명의 학생의 점수이다. 배열을 생성한뒤 33번 ~ 35번 문제를 푸세요.        
> [10, 50, 75, 20, 70, 50, 80]     


```python
score = np.array([10, 50, 75, 20, 70, 50, 80])
```

31. 다음 배열에서 평균 이상의 점수를 받은 학생이 몇명인지 조회       


```python
# score[score >= np.mean(score)] # 평균 이상의 점수 

# 방법 1 
np.sum([score >= np.mean(score)])

# 방법 2 
len(score[score >= np.mean(score)])

# 방법 3 
score[score >= np.mean(score)].size
```

32. 다음 배열에서 평균 이상의 점수를 받은 학생이 전체 학생 중 몇명인지 비율을 조회.        


```python
np.mean(score >= np.mean(score)) * 100 # 42.857142857142854
```

# [33-35번] 
> - 다음 배열은 스무명의 사람들의 연봉의 표본이다.(단위 만원)          
> 배열을 생성한뒤 33번 ~ 35번 문제를 푸세요.            
> [7650, 4210, 7260, 8020, 8200, 8740, 4960, 1420,5410, 9770, 2370, 7960, 8960, 2660, 7940, 5120,7100, 5220, 8810, 253000]     


```python
salary = np.array([7650, 4210, 7260, 8020, 8200, 8740, 4960, 1420,5410, 9770, 2370, 7960, 8960, 2660, 7940, 5120,7100, 5220, 8810, 253000])
```

33. 위 배열에서 상위 75% 는 얼마 이상을 받는지 조회.     


```python
np.quantile(salary, q = 0.75) # 8335.0
```

34. 위 배열에서 하위 25%는 얼마 이하를 받는지 조회.       


```python
np.quantile(salary, q = 0.25) # 5080.0
```

35. 위 배열의 평균과 중앙값을 구하고 배열의 대푯값으로 어떤 것을 사용하는 것이 맞는지 적으세요.        


```python
salary_mean = np.mean(salary) # 평균값 :18739.0
salary_median = np.median(salary) # 중앙값 : 7455.0
```


```python
# 평균 > 중앙값 
# 평균 < 중앙값 
# 많이 차이가 나는 경우 : 극단값이 있는 배열에서는 대푯값을 중앙값으로 사용한다. 
np.sort(salary)
array([  1420,   2370,   2660,   4210,   4960,   5120,   5220,   5410,
         7100,   7260,   7650,   7940,   7960,   8020,   8200,   8740,
         8810,   8960,   9770, 253000])
```
--
# References      
> - 김성환, 엔코아 플레이데이터 (2021, 인공지능 개발자 3기 과정)